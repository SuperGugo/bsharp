{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The B# Programming Language Table of contents Language Spec Data Types Variables Expressions Statements Functions Templates Preprocessing","title":"Home"},{"location":"#the-b-programming-language","text":"","title":"The B# Programming Language"},{"location":"#table-of-contents","text":"Language Spec Data Types Variables Expressions Statements Functions Templates Preprocessing","title":"Table of contents"},{"location":"spec/expressions/","text":"Expressions Variables (or, to be precise, references to variables) are a type of expressions. Everything that returns a value is an expression. Here are all types of expressions in B#: Literals A literal can be of four types: an integer, a float, an array or a template initialization. 4 // an integer literal 0xA6 // another integer literal (hexadecimal) 0b101 // another integer literal (binary) 'a' // another integer literal (char) 0.6 // a float literal [1, 2] // an array literal, composed of integer literals \"hello\" // another array literal, composed of integer literals <1, 3> // a template init literal Assignment An assignment is, in fact, an expression, and not a statement. It returns a value: the new value assigned to the variable. Variables can be assigned values through the following operators: = += -= /= %= *= &= ^= |= ~= >>= <<= ++ // this is equal to += 1 -- // this is equal to -= 1 !! // this performs a logical NOT on the variable Operation B# provides the following operators: + // addition - // subtraction * // multiplication / // division % // modulus & // bitwise AND ^ // bitwise XOR | // bitwise OR ~ // bitwise NOT >> // right bitshift << // left bitshift ! // logical NOT (TODO) && // logical AND || // logical OR ^^ // logical XOR It also provides the following operators to compare the two operands: == != > < >= <= Ternary operator B# implements my favourite feature of programming languages, the ternary operator. x ? a : b // if x, then return a. otherwise, return b. Function call You can call a function and always expect a return value, since void types are not real in B#. As such, every function call is an expression. Casting Casting is done in a very simple way: int x For operations, it is very much reccomended to not trust the order of operation and use brackets: int (x+y)","title":"Expressions"},{"location":"spec/expressions/#expressions","text":"Variables (or, to be precise, references to variables) are a type of expressions. Everything that returns a value is an expression. Here are all types of expressions in B#:","title":"Expressions"},{"location":"spec/expressions/#literals","text":"A literal can be of four types: an integer, a float, an array or a template initialization. 4 // an integer literal 0xA6 // another integer literal (hexadecimal) 0b101 // another integer literal (binary) 'a' // another integer literal (char) 0.6 // a float literal [1, 2] // an array literal, composed of integer literals \"hello\" // another array literal, composed of integer literals <1, 3> // a template init literal","title":"Literals"},{"location":"spec/expressions/#assignment","text":"An assignment is, in fact, an expression, and not a statement. It returns a value: the new value assigned to the variable. Variables can be assigned values through the following operators: = += -= /= %= *= &= ^= |= ~= >>= <<= ++ // this is equal to += 1 -- // this is equal to -= 1 !! // this performs a logical NOT on the variable","title":"Assignment"},{"location":"spec/expressions/#operation","text":"B# provides the following operators: + // addition - // subtraction * // multiplication / // division % // modulus & // bitwise AND ^ // bitwise XOR | // bitwise OR ~ // bitwise NOT >> // right bitshift << // left bitshift ! // logical NOT (TODO) && // logical AND || // logical OR ^^ // logical XOR It also provides the following operators to compare the two operands: == != > < >= <=","title":"Operation"},{"location":"spec/expressions/#ternary-operator","text":"B# implements my favourite feature of programming languages, the ternary operator. x ? a : b // if x, then return a. otherwise, return b.","title":"Ternary operator"},{"location":"spec/expressions/#function-call","text":"You can call a function and always expect a return value, since void types are not real in B#. As such, every function call is an expression.","title":"Function call"},{"location":"spec/expressions/#casting","text":"Casting is done in a very simple way: int x For operations, it is very much reccomended to not trust the order of operation and use brackets: int (x+y)","title":"Casting"},{"location":"spec/functions/","text":"Functions In B#, functions are defined using the fn keyword. They have a return type, parameters and a body that can be executed. For example: fn int add(int a, int b) return a+b; Default parameters Parameters can have default values: they must be the last ones, because they are optional. They are used this way: fn int add(int a, int b=4) return a+b; External functions If you declare a function with extrn fn , the function will be defined at linking time. extrn fn int add(int a, int b);","title":"Functions"},{"location":"spec/functions/#functions","text":"In B#, functions are defined using the fn keyword. They have a return type, parameters and a body that can be executed. For example: fn int add(int a, int b) return a+b;","title":"Functions"},{"location":"spec/functions/#default-parameters","text":"Parameters can have default values: they must be the last ones, because they are optional. They are used this way: fn int add(int a, int b=4) return a+b;","title":"Default parameters"},{"location":"spec/functions/#external-functions","text":"If you declare a function with extrn fn , the function will be defined at linking time. extrn fn int add(int a, int b);","title":"External functions"},{"location":"spec/preprocessing/","text":"Preprocessing Preprocessing directives are lines of code prefixed by a # . B#'s preprocessor implements three directives: include include can be used to include (duh) another file (usually a header file) to your code. The desired file is pasted in your code, replacing the directive. define define can be used to define macros, using the following syntax: #define PI 3.14 undef Forgets a previously set macro.","title":"Preprocessing"},{"location":"spec/preprocessing/#preprocessing","text":"Preprocessing directives are lines of code prefixed by a # . B#'s preprocessor implements three directives:","title":"Preprocessing"},{"location":"spec/preprocessing/#include","text":"include can be used to include (duh) another file (usually a header file) to your code. The desired file is pasted in your code, replacing the directive.","title":"include"},{"location":"spec/preprocessing/#define","text":"define can be used to define macros, using the following syntax: #define PI 3.14","title":"define"},{"location":"spec/preprocessing/#undef","text":"Forgets a previously set macro.","title":"undef"},{"location":"spec/statements/","text":"Statement Statements are fragments of code that get executed in sequence. They, too, can be of different types: Expressions Expressions can be evaluated: however, the result is ignored. Blocks A block is a sequence of statements delimited by curly brackets ( {} ). If Statement An if statement is composed of three parts: a condition, a \"then\" branch, and an optional \"else\" branch. This is the syntax: if (condition) <then branch> else <else branch> Switch Statements A switch statement takes in a value, and compares it to a series of cases (integers). While Loops A while loop executes the body statement as long as the condition is met. The syntax is the following: while (condition) <body> Do-While Loops A do-while loop acts like a while loop, but it runs the body statement at least one time. This is the syntax: do <body> while (condition); For Loops A for loop acts like a while loop, but along with a condition, it has an initialization statement and an \"increment\" statement that runs each time. This is the syntax: for (init; condition; increment) <body> Return Statement Return statements must be in functions (and functions must have at least one return statement). It can take an argument, otherwise, the argument is automatically 0. return <argument>; Break Statement Break and continue statements change the flow of execution: break ends the loop and skips to the end, while continue simply skips to the next iteration of the loop. Inline Assembly B# supports writing inline assembly code as a statement. The syntax is using the keyword asm followed by a string literal.","title":"Statements"},{"location":"spec/statements/#statement","text":"Statements are fragments of code that get executed in sequence. They, too, can be of different types:","title":"Statement"},{"location":"spec/statements/#expressions","text":"Expressions can be evaluated: however, the result is ignored.","title":"Expressions"},{"location":"spec/statements/#blocks","text":"A block is a sequence of statements delimited by curly brackets ( {} ).","title":"Blocks"},{"location":"spec/statements/#if-statement","text":"An if statement is composed of three parts: a condition, a \"then\" branch, and an optional \"else\" branch. This is the syntax: if (condition) <then branch> else <else branch>","title":"If Statement"},{"location":"spec/statements/#switch-statements","text":"A switch statement takes in a value, and compares it to a series of cases (integers).","title":"Switch Statements"},{"location":"spec/statements/#while-loops","text":"A while loop executes the body statement as long as the condition is met. The syntax is the following: while (condition) <body>","title":"While Loops"},{"location":"spec/statements/#do-while-loops","text":"A do-while loop acts like a while loop, but it runs the body statement at least one time. This is the syntax: do <body> while (condition);","title":"Do-While Loops"},{"location":"spec/statements/#for-loops","text":"A for loop acts like a while loop, but along with a condition, it has an initialization statement and an \"increment\" statement that runs each time. This is the syntax: for (init; condition; increment) <body>","title":"For Loops"},{"location":"spec/statements/#return-statement","text":"Return statements must be in functions (and functions must have at least one return statement). It can take an argument, otherwise, the argument is automatically 0. return <argument>;","title":"Return Statement"},{"location":"spec/statements/#break-statement","text":"Break and continue statements change the flow of execution: break ends the loop and skips to the end, while continue simply skips to the next iteration of the loop.","title":"Break Statement"},{"location":"spec/statements/#inline-assembly","text":"B# supports writing inline assembly code as a statement. The syntax is using the keyword asm followed by a string literal.","title":"Inline Assembly"},{"location":"spec/templates/","text":"Templates Templates are a feature of B#, comparable to C's structs. They can hold members (variables) and can have methods (functions exclusive to them). Definition Templates are defined using the keyword template : template MyTemp<int x, int y>; Assignment You can declare a variable as template and, optionally, assign a value to it: auto MyTemp myVar = <1, 3> Default values in templates You can also set default values to a template's members: template MyTemp<int x = 5, int y = 8>; If you don't, on an empty initialization it will not be initialized and will be memory noise. auto MyTemp myVar = <> // the same as writing <5, 8> Methods Methods of a template are defined like this: fn int MyTemp::myFunction() { return self.x; } When a method is defined, a default argument self is passed to it, which refers to the parent template. Accessing members / methods You can access a the members of a variable defined with a template with the . operator: auto int myInt = myVar.x; You can also access a member of a pointer that points to a template with the -> operator: auto MyTemp* myPtr = &myVar; auto int myInt = myPtr->x;","title":"Templates"},{"location":"spec/templates/#templates","text":"Templates are a feature of B#, comparable to C's structs. They can hold members (variables) and can have methods (functions exclusive to them).","title":"Templates"},{"location":"spec/templates/#definition","text":"Templates are defined using the keyword template : template MyTemp<int x, int y>;","title":"Definition"},{"location":"spec/templates/#assignment","text":"You can declare a variable as template and, optionally, assign a value to it: auto MyTemp myVar = <1, 3>","title":"Assignment"},{"location":"spec/templates/#default-values-in-templates","text":"You can also set default values to a template's members: template MyTemp<int x = 5, int y = 8>; If you don't, on an empty initialization it will not be initialized and will be memory noise. auto MyTemp myVar = <> // the same as writing <5, 8>","title":"Default values in templates"},{"location":"spec/templates/#methods","text":"Methods of a template are defined like this: fn int MyTemp::myFunction() { return self.x; } When a method is defined, a default argument self is passed to it, which refers to the parent template.","title":"Methods"},{"location":"spec/templates/#accessing-members-methods","text":"You can access a the members of a variable defined with a template with the . operator: auto int myInt = myVar.x; You can also access a member of a pointer that points to a template with the -> operator: auto MyTemp* myPtr = &myVar; auto int myInt = myPtr->x;","title":"Accessing members / methods"},{"location":"spec/types/","text":"Data Types B# provides six primitive types. Templates and arrays are also considered types. B# does not provide any unsigned integer types. Primitive types char Signed integer type. 1 byte wide. short Signed integer type. 2 byte wide. int Signed integer type. 4 byte wide. long Signed integer type. 8 byte wide. float Floating point type. 4 bytes wide. double Double precision floating point type. 8 bytes wide. Pointers Pointers are considered longs. As such, they are 8 bytes wide. \"AmbiguousInteger\" B# treats integer literals as \"AmbigousIntegers\", which are 8 bytes wide and can be downcasted implicitly. Note: this will be replaced when implicit casting is implemented, as literals will have a flag to allow downcasting. Arrays Arrays are static (their size cannot be changed), and they are declaredlike this: auto int arr[5] = [1, 2, 3, 4, 5]; This creates an array of size 5 and populates it with the given values. (TODO) Arrays can also be populated with a single value: auto int arr[5] = [2]; // This is the same as [2, 2, 2, 2, 2] sizeof sizeof can be used to obtain the size of a type: auto int z = sizeof float; // z equals 4 or of an already defined variable: auto int x; auto int z = sizeof x; // z equals 4 In reality, sizeof can return the size of any expression: auto int z = sizeof [1, 2, 4]; // z equals 24","title":"Data Types"},{"location":"spec/types/#data-types","text":"B# provides six primitive types. Templates and arrays are also considered types. B# does not provide any unsigned integer types.","title":"Data Types"},{"location":"spec/types/#primitive-types","text":"char Signed integer type. 1 byte wide. short Signed integer type. 2 byte wide. int Signed integer type. 4 byte wide. long Signed integer type. 8 byte wide. float Floating point type. 4 bytes wide. double Double precision floating point type. 8 bytes wide.","title":"Primitive types"},{"location":"spec/types/#pointers","text":"Pointers are considered longs. As such, they are 8 bytes wide.","title":"Pointers"},{"location":"spec/types/#ambiguousinteger","text":"B# treats integer literals as \"AmbigousIntegers\", which are 8 bytes wide and can be downcasted implicitly. Note: this will be replaced when implicit casting is implemented, as literals will have a flag to allow downcasting.","title":"\"AmbiguousInteger\""},{"location":"spec/types/#arrays","text":"Arrays are static (their size cannot be changed), and they are declaredlike this: auto int arr[5] = [1, 2, 3, 4, 5]; This creates an array of size 5 and populates it with the given values. (TODO) Arrays can also be populated with a single value: auto int arr[5] = [2]; // This is the same as [2, 2, 2, 2, 2]","title":"Arrays"},{"location":"spec/types/#sizeof","text":"sizeof can be used to obtain the size of a type: auto int z = sizeof float; // z equals 4 or of an already defined variable: auto int x; auto int z = sizeof x; // z equals 4 In reality, sizeof can return the size of any expression: auto int z = sizeof [1, 2, 4]; // z equals 24","title":"sizeof"},{"location":"spec/variables/","text":"Variables Variables are references to a memory area. They each have a type and a storage duration specifier. Storage Duration When declaring a variable, the first thing you need to specify is the storage duration, which tells the compiler where the variable will be accessible from. This can be done through the use of three specifiers: auto auto is the default specifier, <(TODO) and as such it can be omitted>. It makes the variable only accessible from the scope it was declared in. If the variable was declared outside any scope, it is a global variable, and can be used anywhere in the program. static Static variables are considered global, even if declared inside a scope. (TODO) Static variables, like auto variables, can only be used in the scope they were declared in, but their value persists between function calls. extrn extrn variables are declared, but not defined. They are, in fact, only defined at linking time. They are most useful in header files. Actually, I don't see a case where you would use it outside a header file. Note: Definition of a variable is the process in which the variable is assigned an address in memory. Declaration With all these things considered, this is how a variable is declared: auto int x; In order: a storage duration specifier, a data type (which, technically, can be omitted and defaults as int) and an identifier. Reference Variables can be referenced in three ways: as values, by simply using the variable's identifier: x as references (a reference to the area of memory where the variable is stored) &x Note: this returns a pointer. If x was of type int, &x will be of type int*. as pointers (returns the value in the memory area pointed to by the variable) *x Note: this takes in a pointer. If x was of type int , x will be of type int. In a broader sense, the subscript operator [] is also a variable reference: it is a pointer to an addition between the reference of the variable and the value inside the subscript operator. The same concept also applies to the template member access . operator and the template member of pointer access -> operator, respectively used to access a member of a template type variable and a pointer of a template.","title":"Variables"},{"location":"spec/variables/#variables","text":"Variables are references to a memory area. They each have a type and a storage duration specifier.","title":"Variables"},{"location":"spec/variables/#storage-duration","text":"When declaring a variable, the first thing you need to specify is the storage duration, which tells the compiler where the variable will be accessible from. This can be done through the use of three specifiers: auto auto is the default specifier, <(TODO) and as such it can be omitted>. It makes the variable only accessible from the scope it was declared in. If the variable was declared outside any scope, it is a global variable, and can be used anywhere in the program. static Static variables are considered global, even if declared inside a scope. (TODO) Static variables, like auto variables, can only be used in the scope they were declared in, but their value persists between function calls. extrn extrn variables are declared, but not defined. They are, in fact, only defined at linking time. They are most useful in header files. Actually, I don't see a case where you would use it outside a header file. Note: Definition of a variable is the process in which the variable is assigned an address in memory.","title":"Storage Duration"},{"location":"spec/variables/#declaration","text":"With all these things considered, this is how a variable is declared: auto int x; In order: a storage duration specifier, a data type (which, technically, can be omitted and defaults as int) and an identifier.","title":"Declaration"},{"location":"spec/variables/#reference","text":"Variables can be referenced in three ways: as values, by simply using the variable's identifier: x as references (a reference to the area of memory where the variable is stored) &x Note: this returns a pointer. If x was of type int, &x will be of type int*. as pointers (returns the value in the memory area pointed to by the variable) *x Note: this takes in a pointer. If x was of type int , x will be of type int. In a broader sense, the subscript operator [] is also a variable reference: it is a pointer to an addition between the reference of the variable and the value inside the subscript operator. The same concept also applies to the template member access . operator and the template member of pointer access -> operator, respectively used to access a member of a template type variable and a pointer of a template.","title":"Reference"}]}